library(stringr)
# 1. Original word list
wordlist <- c("peat", "seat", "feet", "deep", "beat", "seek", "teeth", "peak", "sheet", "keep", "beep", "cheek",
"kit", "ship", "tip", "fit", "pit", "pick", "tick", "sit", "chip", "sip", "bit", "dip",
"tape", "cake", "cape", "date", "gate", "take", "safe", "fake", "fate", "shape", "bait", "sake",
"dead", "get", "beg", "bet", "debt", "peck", "deck", "pet", "pep", "vet", "jet", "bed",
"gap", "pack", "tap", "sat", "bat", "pat", "cap", "tat", "cat", "fat", "zap", "tax",
"dot", "got", "pox", "tot", "jock", "shot", "sock", "dock", "cop", "pot", "not", "box",
"soup", "duke", "dupe", "food", "boot", "loop", "kook", "tube", "tooth", "suit", "shoot", "goop",
"caught", "bought", "taught", "thought", "fought", "sought", "moss", "boss", "talk", "loss", "toss",
"walk")
# 2. Full passage text
passage <- tolower("
I took a seat and had a beep next to my teeth. I bit down. A sudden zap shocked a lazy cat, light on its feet. It jumped onto a deck. It made me want to seek out some mice. I quickly looked at my kit and began to dig some peat next to a shallow pit, mindful not to step in some soft moss, or get stuff on my cheek. My pal wanted to toss some soda at me.
At a shop, I ate soup, a slice of cake, and a sip of soda, all safe. Outside, a jock who had a sock tossed a baseball bat with a beat. Someone shouted, and I almost shot out of my place.
A cop helped me pick a gift—a sheet of goop—I asked if it was a dupe. I bought a small wooden box and put it gently in my pack. I felt like I was at my peak.
At home, I couldn't keep my eyes open and chose to sit on my bed, next to my boot. A quick tick from a clock made me think of a missed date and a tax which had led to debt which was fit.
A fake duke who had on a suit and a cape spoke about his fate on a ship and how he had once yelled about a dot on a tip of an old map. He has an old tat of a fat tooth who had a tube of paste. He got it when he was caught in a storm just as he saw a dock. Once, he spoke about how he had taken a dip in seas full of fish. He was a kook. Goodness sake.
I sought to talk to my boss about how I was dead sleepy. Instead, I had a bowl of food, watched a film about a chip, fell asleep, and saw a big gate. I woke up to a shape of someone about to take my tape. I had to beg my pal to go find some and fix the loss.
Last night, I saw a tiny tot who had a toy. I also saw a vet who made a bet and found a tap. I saw a jet that was mid-flight, and a duck who liked to peck. I saw a skater, about to shoot the gap, a mate who had lots of pep, and a flock of birds who fought about some bait. I saw a pet that sat, who liked a pat. I saw a soda bottle with no cap, and a baby who had chicken pox that runs about a loop. I saw a chute of waste and a pot of gold. A bell sounded loud and deep. I woke up and had one last sleepy thought. I went and took a walk and found some soda. Overall, this taught me some lessons.
")
# 3. Tokenize and count
tokens <- str_extract_all(passage, "\\b[a-z]+\\b")[[1]]
counts <- table(factor(tokens, levels = wordlist))
# 4. Check for missing or duplicated words
missing <- names(counts[counts == 0])
duplicates <- names(counts[counts > 1])
# 5. Output results
if (length(missing) == 0 && length(duplicates) == 0) {
cat("✅ All 84 words are used exactly once.\n")
} else {
if (length(missing) > 0) {
cat("❌ Missing words:\n")
print(missing)
}
if (length(duplicates) > 0) {
cat("⚠️ Duplicated words:\n")
print(duplicates)
}
}
library(tidyverse)
set.seed(456)  # Explicitly set seed for reproducibility
# Load the dataset explicitly and remove 'if_ex_y' column
voices <- read_csv("data/metadata/voices_metadata.csv") %>%
select(-if_ex_y)
library(tidyverse)
# --- Directories ---
fig_dir   <- "/Users/noahkhaloo/Desktop/Tigre_data/figures"
stats_dir <- "/Users/noahkhaloo/Desktop/Tigre_data/summary_stats"
dir.create(fig_dir,   recursive = TRUE, showWarnings = FALSE)
dir.create(stats_dir, recursive = TRUE, showWarnings = FALSE)
# --- Load, select/rename ---
df <- read_delim(
"/Users/noahkhaloo/Desktop/Tigre_data/pilot/ejective_measurements.csv",
delim   = "\t",
locale  = locale(encoding = "UTF-16")
) %>%
select(
filename,
pos,
seg,
burst_duration        = bDur,
mean_burst_intensity  = bMeanInt,
burst_CoG             = bcog,
aspiration_duration   = rhDur,
glottalC_duration     = rsDur,
frication_duration    = rfDur,
frication_CoG         = rfcog,
VOT                   = posvot,
post_burst_duration   = rDur,
closure_duration      = cDur
) %>%
# --- Derive position & phoneme from seg, THEN classify ---
mutate(
position = if_else(str_detect(seg, "_post_v$"), "post_vocalic", "pre_vocalic"),
phoneme  = str_remove(seg, "_.*$"),
# ejective: allow ASCII ' or Unicode ’ at end of phoneme
ejective = factor(
if_else(str_detect(phoneme, "('|’)$"), "y", "n"),
levels = c("y","n")  # 'y' first
),
# fricative heuristic (expand later if you add more fricatives)
fricative = if_else(str_starts(phoneme, "s"), "y", "n"),
# base form without apostrophe for ordering pairs
phon_base = str_remove(phoneme, "('|’)$")
)
# --- Ensure ejectives appear first on x-axis within each base (k' then k, t' then t, …) ---
phoneme_levels <- df %>%
distinct(phon_base, phoneme, ejective) %>%
mutate(ej_ord = if_else(ejective == "y", 0L, 1L)) %>%
arrange(phon_base, ej_ord) %>%
pull(phoneme)
df <- df %>%
mutate(phoneme = factor(phoneme, levels = unique(phoneme_levels)))
# --- Theme & saver ---
clean_theme <- theme_minimal() +
theme(
legend.position  = "top",
axis.text.x      = element_text(size = 14),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
panel.background = element_rect(fill = "white", colour = NA),
plot.background  = element_rect(fill = "white", colour = NA),
axis.line        = element_line(color = "black")
)
save_plot <- function(plot, filename) {
ggsave(filename = file.path(fig_dir, filename),
plot = plot, width = 6, height = 4, dpi = 300, bg = "white")
}
# --- Summary helper (no position in grouping; kept for CSVs) ---
compute_summary_no_position <- function(data, measure, subset = NULL) {
subset_q <- rlang::enquo(subset)
d <- if (!rlang::quo_is_null(subset_q)) dplyr::filter(data, !!subset_q) else data
d %>%
group_by(phoneme, ejective) %>%
summarise(
mean = mean(.data[[measure]], na.rm = TRUE),
sd   = sd(.data[[measure]],   na.rm = TRUE),
n    = sum(!is.na(.data[[measure]])),
.groups = "drop"
) %>%
mutate(
se = sd / sqrt(pmax(n, 1)),
measure = measure
) %>%
relocate(measure, .before = phoneme)
}
# --- Violin+box+points helper (token-level), optional subset; safe for small groups ---
make_violin_no_position <- function(
data, measure,
subset = NULL, y_label = NULL, title = NULL, filename = NULL,
trim = FALSE, point_alpha = 0.75, point_size = 1, jitter_width = 0.14,
min_n_for_violin = 2
) {
if (is.null(y_label))  y_label  <- measure
# Default title: just the measure name (no extras)
if (is.null(title))    title    <- gsub("_", " ", measure)
if (is.null(filename)) filename <- paste0(measure, "_violin.png")
msym <- rlang::sym(measure)
subset_q <- rlang::enquo(subset)
rawdf <- if (!rlang::quo_is_null(subset_q)) dplyr::filter(data, !!subset_q) else data
rawdf <- rawdf %>% filter(!is.na(!!msym))
if (nrow(rawdf) == 0) return(invisible(NULL))
# Count tokens per (phoneme, ejective) group
grp_counts <- rawdf %>% count(phoneme, ejective, name = "n")
df_violin  <- rawdf %>%
semi_join(filter(grp_counts, n >= min_n_for_violin), by = c("phoneme","ejective"))
# Always plot points for *all* tokens (including singletons)
df_points  <- rawdf
# Shared positioning
dodge_w <- 0.8
dodge   <- position_dodge(width = dodge_w)
jitdod  <- ggplot2::position_jitterdodge(jitter.width = jitter_width,
jitter.height = 0,
dodge.width  = dodge_w)
show_legend <- dplyr::n_distinct(rawdf$ejective) > 1
p <- ggplot() +
geom_violin(
data = df_violin,
aes(x = phoneme, y = !!msym, fill = ejective,
group = interaction(phoneme, ejective)),
trim = trim, scale = "width", position = dodge, width = 0.7, alpha = 0.9
) +
geom_boxplot(
data = df_violin,
aes(x = phoneme, y = !!msym, fill = ejective,
group = interaction(phoneme, ejective)),
width = 0.10, outlier.shape = NA, position = dodge, alpha = 0.95
) +
geom_point(
data = df_points,
aes(x = phoneme, y = !!msym, fill = ejective,
group = interaction(phoneme, ejective)),
position = jitdod, size = point_size, alpha = point_alpha,
shape = 16, stroke = 0
) +
labs(x = "Phoneme", y = y_label, title = title, fill = "Ejective") +
clean_theme +
theme(legend.position = if (show_legend) "top" else "none") +
scale_y_continuous(expand = expansion(mult = c(0, 0.05)))
save_plot(p, filename)
p
}
# --- Measure sets ---
fric_measures <- c("frication_duration", "frication_CoG")  # fricatives only
stop_measures <- c("burst_duration", "mean_burst_intensity", "burst_CoG", "VOT", "post_burst_duration")  # non-fricatives only
# =========================
# PRE-VOCALIC ONLY ANALYSES
# =========================
# 1) Summaries (pre-vocalic): frication on fricatives; stop-measures on non-fricatives
all_summaries_pre_v <- bind_rows(
purrr::map_dfr(fric_measures, ~ compute_summary_no_position(
df, .x, subset = (fricative == "y" & position == "pre_vocalic")
)),
purrr::map_dfr(stop_measures, ~ compute_summary_no_position(
df, .x, subset = (fricative == "n" & position == "pre_vocalic")
))
)
write_csv(all_summaries_pre_v, file.path(stats_dir, "summary_pre_vocalic_by_phoneme_ejective_filtered.csv"))
# (Optional) per-measure CSVs
purrr::walk(fric_measures, ~ compute_summary_no_position(
df, .x, subset = (fricative == "y" & position == "pre_vocalic"))
%>% write_csv(file.path(stats_dir, paste0(.x, "_summary_pre_vocalic_fricatives.csv")))
)
purrr::walk(stop_measures, ~ compute_summary_no_position(
df, .x, subset = (fricative == "n" & position == "pre_vocalic"))
%>% write_csv(file.path(stats_dir, paste0(.x, "_summary_pre_vocalic_nonfricatives.csv")))
)
# 2) Violin+box+points (pre-vocalic): frication on fricatives; stop-measures on non-fricatives
purrr::walk(fric_measures, function(m) {
make_violin_no_position(
df, m,
subset   = (fricative == "y" & position == "pre_vocalic"),
title    = gsub("_", " ", m),
filename = paste0(m, "_pre_vocalic_violin.png")
)
})
purrr::walk(stop_measures, function(m) {
make_violin_no_position(
df, m,
subset   = (fricative == "n" & position == "pre_vocalic"),
title    = gsub("_", " ", m),
filename = paste0(m, "_pre_vocalic_violin.png")
)
})
# =========================
# CLOSURE DURATION (SPECIAL)
# =========================
# Single violin; only word-medial tokens (pos == 2), only non-fricatives (ignore pre/post).
closure_summary <- compute_summary_no_position(
df, "closure_duration",
subset = (fricative == "n" & pos %in% c(2, "2"))
)
write_csv(
closure_summary,
file.path(stats_dir, "closure_duration_summary_pos2_nonfricatives.csv")
)
make_violin_no_position(
df, "closure_duration",
subset   = (fricative == "n" & pos %in% c(2, "2")),
y_label  = "Closure Duration (s)",
title    = "Closure Duration (word-medial; pos = 2)",
filename = "closure_duration_pos2_violin.png"
)
# =========================
# GLOTTAL CONSTRICTION DURATION — EJECTIVES ONLY (ALL TOKENS)
# =========================
glottalC_summary_all_ej <- compute_summary_no_position(
df, "glottalC_duration",
subset = (ejective == "y")
)
write_csv(
glottalC_summary_all_ej,
file.path(stats_dir, "glottalC_duration_ejectives_summary.csv")
)
make_violin_no_position(
df, "glottalC_duration",
subset   = (ejective == "y"),
y_label  = "Glottal Constriction Duration (s)",
title    = "Glottal Constriction Duration (ejectives only)",
filename = "glottalC_duration_ejectives_violin.png"
)
#vowels
library(tidyverse)
# ---------- Load + select/rename + derive columns ----------
vowels <- readr::read_csv("/Users/noahkhaloo/Desktop/Tigre_data/pilot/output.csv", guess_max = 100000)
vowels <- vowels %>%
select(
Filename,
Label,
seg_Start,
seg_End,
t_ms,
`H1*-H2*` = H1H2c,     # keep backticks when referencing later
SoE       = soe,       # use 'soe' from file; rename to SoE
HNR05,
F0  = strF0,
F1  = pF1,
F2  = pF2,
F3  = pF3
) %>%
mutate(
# NEW: flag tokens ending in "_a", then strip "_a" so later logic isn't affected
a_harmony = if_else(stringr::str_ends(Label, "_a"), "y", "n"),
Label     = stringr::str_remove(Label, "_a$"),
# Expand closure abbreviations at Label end (after removing _a)
Label_clean = Label %>%
stringr::str_replace("rs$", "post_release_closure") %>%
stringr::str_replace("c$",  "pre_release_closure"),
# Preceding: first segment (keep apostrophe if present): k / k'
preceding_consonant = stringr::str_match(Label, "^([[:alpha:]][’']?)")[, 2],
# Preceding ejective flag (y first)
preceding_ejective = factor(
dplyr::if_else(!is.na(preceding_consonant) & stringr::str_detect(preceding_consonant, "['’]$"), "y", "n"),
levels = c("y","n")
),
# Remove trailing closure tag (c/rs) BEFORE getting the following consonant
label_no_closure = stringr::str_remove(Label, "(rs|c)$"),
# Following: last segment = single letter with optional apostrophe, OR '#'
# e.g., "let'c" -> "t'", "ra#" -> "#"
following_consonant = stringr::str_extract(label_no_closure, "([[:alpha:]](?:['’])?|#)$"),
# Following ejective flag (y first)
following_ejective = factor(
dplyr::case_when(
is.na(following_consonant)                 ~ "n",
following_consonant == "#"                 ~ "n",
stringr::str_detect(following_consonant, "['’]$") ~ "y",
TRUE                                       ~ "n"
),
levels = c("y","n")
),
# Vowel core = remove first seg, trailing closure (if any), then last symbol (letter+' or #)
vowel_core = Label %>%
stringr::str_remove("^([[:alpha:]][’']?)") %>%
stringr::str_remove("(rs|c)$") %>%
stringr::str_remove("([[:alpha:]](?:['’])?|#)$"),
# Map only 'e' -> 'ə'; anything else -> "0"
Vowel = dplyr::case_when(
vowel_core %in% c("e", "E") ~ "ə",
TRUE                         ~ "0"
)
)
# ---------- Figures dir ----------
fig_dir <- "/Users/noahkhaloo/Desktop/Tigre_data/figures"
dir.create(fig_dir, recursive = TRUE, showWarnings = FALSE)
# ---------- mean_cl_boot fallback (if not defined elsewhere) ----------
if (!exists("mean_cl_boot")) {
mean_cl_boot <- function(x, conf.int = 0.95) {
x <- x[is.finite(x)]
if (length(x) < 2) return(data.frame(y = mean(x), ymin = mean(x), ymax = mean(x)))
m <- mean(x); s <- stats::sd(x); n <- length(x)
se <- s / sqrt(n); mult <- stats::qt((1 + conf.int) / 2, df = max(n - 1, 1))
data.frame(y = m, ymin = m - mult * se, ymax = m + mult * se)
}
}
# ---------- Build 9-bin normalized time (ə only) ----------
vowels_tc <- vowels %>%
mutate(
dur_ms   = as.numeric(seg_End - seg_Start),
prog     = if_else(dur_ms > 0, (t_ms - seg_Start) / dur_ms, NA_real_),
prog     = pmin(pmax(prog, 0), 0.999999),  # clamp to [0,1)
Timecourse = cut(
prog, breaks = seq(0, 1, length.out = 10),
include.lowest = TRUE, right = FALSE, labels = as.character(1:9)
)
) %>%
filter(Vowel == "ə", !is.na(Timecourse))
# ---------- Helper: safe filename slugs ----------
.safe_slug <- function(x) {
x <- gsub("[’′']", "prime", x)     # normalize apostrophes/primes to 'prime'
gsub("[^A-Za-z0-9]+", "", x)       # remove non-alphanumerics
}
# ---------- Plot helpers ----------
make_timecourse_plot_preceding <- function(data, measure, pair_set, y_lab, title_text) {
msym <- rlang::sym(measure)
ggplot(
data %>% filter(preceding_consonant %in% pair_set),
aes(x = Timecourse, y = !!msym,
color = preceding_ejective, shape = preceding_ejective,
linetype = preceding_ejective, group = preceding_ejective)
) +
theme_bw(base_size = 16) +
stat_summary(fun.data = mean_cl_boot, geom = "errorbar", width = 0.12) +
stat_summary(fun = mean, geom = "point", size = 3, aes(fill = preceding_ejective)) +
stat_summary(fun = mean, geom = "line",  size = 1.5) +
scale_x_discrete(labels = as.character(1:9)) +
scale_shape_manual(values    = c("y" = 23, "n" = 21)) +
scale_fill_manual(values     = c("y" = "white", "n" = "black")) +
scale_linetype_manual(values = c("y" = "solid", "n" = "dashed")) +
scale_color_manual(values    = c("y" = "#E74C3C", "n" = "#00A3A3")) +
labs(x = "Normalized time", y = y_lab, title = title_text,
color = "preceding ejective", shape = "preceding ejective",
linetype = "preceding ejective", fill = "preceding ejective") +
theme(legend.key.width = grid::unit(1.6, "cm"))
}
make_timecourse_plot_following <- function(data, measure, pair_set, y_lab, title_text) {
msym <- rlang::sym(measure)
ggplot(
data %>% filter(following_consonant %in% pair_set),
aes(x = Timecourse, y = !!msym,
color = following_ejective, shape = following_ejective,
linetype = following_ejective, group = following_ejective)
) +
theme_bw(base_size = 16) +
stat_summary(fun.data = mean_cl_boot, geom = "errorbar", width = 0.12) +
stat_summary(fun = mean, geom = "point", size = 3, aes(fill = following_ejective)) +
stat_summary(fun = mean, geom = "line",  size = 1.5) +
scale_x_discrete(labels = as.character(1:9)) +
scale_shape_manual(values    = c("y" = 23, "n" = 21)) +
scale_fill_manual(values     = c("y" = "white", "n" = "black")) +
scale_linetype_manual(values = c("y" = "solid", "n" = "dashed")) +
scale_color_manual(values    = c("y" = "#E74C3C", "n" = "#00A3A3")) +
labs(x = "Normalized time", y = y_lab, title = title_text,
color = "following ejective", shape = "following ejective",
linetype = "following ejective", fill = "following ejective") +
theme(legend.key.width = grid::unit(1.6, "cm"))
}
# ---------- Measures & pairs (F3 included) ----------
measures <- tibble::tribble(
~var,          ~ylab,            ~title_prefix,
"H1*-H2*",     "H1*-H2* (dB)",   "H1*-H2*",
"HNR05",       "HNR (dB)",       "HNR",
"SoE",         "SoE",            "SoE",
"F1",          "F1 (Hz)",        "F1",
"F2",          "F2 (Hz)",        "F2",
"F3",          "F3 (Hz)",        "F3",
"F0",          "F0 (Hz)",        "F0"
)
pairs <- list(
list(set = c("k'", "k"), label = "k′ vs k"),
list(set = c("t'", "t"), label = "t′ vs t"),
list(set = c("s'", "s"), label = "s′ vs s")
)
# ---------- Generate & SAVE: PRECEDING plots (exclude tokens with a following ejective) ----------
plots_pre <- list(); idx_pre <- 1
for (p in pairs) {
dat_p <- vowels_tc %>%
filter(
preceding_consonant %in% p$set,
following_ejective == "n"   # drop cases with any following ejective
)
if (nrow(dat_p) == 0) next
for (i in seq_len(nrow(measures))) {
m  <- measures[i, ]
if (all(!is.finite(dat_p[[m$var]]))) next
pl <- make_timecourse_plot_preceding(
dat_p, m$var, p$set,
y_lab = m$ylab,
title_text = paste0(m$title_prefix, " — preceding ", p$label)
)
print(pl)
ggsave(
filename = file.path(
fig_dir,
paste0(.safe_slug(m$title_prefix), "_preceding_", .safe_slug(p$label), "_timecourse.png")
),
plot = pl, width = 7.5, height = 4, dpi = 300, bg = "white"
)
plots_pre[[idx_pre]] <- pl; idx_pre <- idx_pre + 1
}
}
