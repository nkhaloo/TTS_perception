<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Racial Judgment Experiment</title>
  <style>
    body { font-family: sans-serif; background: #f5f5f5; margin: 0; padding: 20px; }
    .card { background: white; border-radius: 8px; padding: 20px; max-width: 900px; margin: 0 auto; box-shadow: 0 2px 6px rgba(0,0,0,0.1); }
    h1 { font-size: 24px; margin-top: 0; }
    .btn { padding: 10px 16px; border: none; border-radius: 6px; cursor: pointer; }
    .btn-primary { background: #007acc; color: white; }
    .hidden { display: none; }
    .progress { height: 8px; background: #eee; border-radius: 4px; margin: 10px 0; overflow: hidden; }
    .progress > div { height: 100%; background: #007acc; width: 0; }
    table { width: 100%; border-collapse: collapse; margin-top: 16px; }
    th, td { padding: 8px; text-align: center; }
    td:first-child { text-align: left; }
    input[type="radio"] { margin: 0 auto; display: block; }
  </style>
</head>
<body>
  <div class="card" id="screen-intro">
    <h1>Audio Judgment Study</h1>
    <p>You will hear short recordings from different speakers and answer a quick question after each one. There are two blocks: Personality and Race. The assignment is randomized per participant.</p>
    <button class="btn btn-primary" id="startBtn">Start Experiment</button>
  </div>

  <div class="card hidden" id="screen-block">
    <h1 id="blockTitle">Block</h1>
    <div id="trialCounter">Trial 1 / 64</div>
    <div class="progress"><div id="progressBar"></div></div>
    <p>Please press Play to listen to the audio:</p>
    <audio id="player" preload="auto" controls controlsList="nodownload noplaybackrate"></audio>
    <div id="questionsContainer"></div>
    <div style="margin-top:12px;">
      <button class="btn btn-primary" id="nextBtn" disabled>Next</button>
    </div>
  </div>

  <div class="card hidden" id="screen-finish">
    <h1>All Done!</h1>
    <p>Thank you for participating. Download your responses below:</p>
    <button class="btn btn-primary" id="downloadBtn">Download CSV</button>
  </div>

  <script>
    const CONFIG = {
      assetsBase: 'data/soundfiles',
      stimuli: ['central', 'fronting', 'mono', 'raising'],
      suffix: '.wav',
      questions: {
        Personality: [
          "How friendly does this speaker sound?",
          "How professional does this speaker sound?",
          "How funny does this speaker sound?",
          "How competent does this speaker sound?",
          "How trustworthy does this speaker sound?",
          "How pleasant does this speaker sound?"
        ],
        Race: [
          "Placeholder race question (1â€“7)"
        ]
      },
      bins: ['BF', 'BM', 'WF', 'WM'],
      numsPerBin: 8,
      scaleMin: 1,
      scaleMax: 7
    };

    function shuffle(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
      return array;
    }

    function buildAllSpeakers() {
      const speakers = [];
      for (const bin of CONFIG.bins) {
        for (let n = 1; n <= CONFIG.numsPerBin; n++) {
          speakers.push(`${bin}${n}`);
        }
      }
      return speakers;
    }

    function speakerPrefixToBin(prefix) {
      return prefix.replace(/\d+$/, '');
    }

    function balancedSplit(speakers) {
      const groupsByBin = Object.fromEntries(CONFIG.bins.map(b => [b, []]));
      for (const s of speakers) groupsByBin[speakerPrefixToBin(s)].push(s);
      for (const b of CONFIG.bins) shuffle(groupsByBin[b]);
      const groupA = [], groupB = [];
      for (const b of CONFIG.bins) {
        groupA.push(...groupsByBin[b].slice(0, 4));
        groupB.push(...groupsByBin[b].slice(4, 8));
      }
      return { A: groupA, B: groupB };
    }

    function buildBlockTrials(groupSpeakers, blockLabel) {
      const trials = [];
      for (const spk of groupSpeakers) {
        for (const stim of CONFIG.stimuli) {
          trials.push({
            block: blockLabel,
            speaker: spk,
            bin: speakerPrefixToBin(spk),
            stimulus: stim,
            url: `${CONFIG.assetsBase}/${stim}/${spk}_${stim}${CONFIG.suffix}`
          });
        }
      }
      return shuffle(trials);
    }

    function toCSV(rows) {
      const esc = v => '"' + String(v).replace(/"/g, '""') + '"';
      const headers = Object.keys(rows[0] || {});
      return [headers.join(','), ...rows.map(r => headers.map(h => esc(r[h] ?? '')).join(','))].join('\n');
    }

    const State = { blocks: {}, order: [], currentBlock: null, trialIndex: 0, data: [], startedAt: null };

    const intro = document.getElementById('screen-intro');
    const block = document.getElementById('screen-block');
    const finish = document.getElementById('screen-finish');
    const blockTitle = document.getElementById('blockTitle');
    const trialCounter = document.getElementById('trialCounter');
    const progressBar = document.getElementById('progressBar');
    const player = document.getElementById('player');
    const questionsContainer = document.getElementById('questionsContainer');
    const nextBtn = document.getElementById('nextBtn');
    const downloadBtn = document.getElementById('downloadBtn');

    function renderQuestions(questions) {
      let html = '<table><tr><th></th>';
      for (let v = CONFIG.scaleMin; v <= CONFIG.scaleMax; v++) {
        html += `<th>${v}</th>`;
      }
      html += '</tr>';

      questions.forEach((q, i) => {
        html += `<tr><td>${q}</td>`;
        for (let v = CONFIG.scaleMin; v <= CONFIG.scaleMax; v++) {
          const id = `q${i}_${v}`;
          html += `<td><input type=\"radio\" name=\"q${i}\" value=\"${v}\" id=\"${id}\"></td>`;
        }
        html += '</tr>';
      });
      html += '</table>';
      questionsContainer.innerHTML = html;

      document.querySelectorAll('input[type=radio]').forEach(inp => {
        inp.addEventListener('change', () => {
          nextBtn.disabled = !allAnswered(questions.length);
        });
      });
    }

    function allAnswered(numQs) {
      for (let i = 0; i < numQs; i++) {
        if (!document.querySelector(`input[name="q${i}"]:checked`)) return false;
      }
      return true;
    }

    document.getElementById('startBtn').addEventListener('click', startExperiment);

    function startExperiment() {
      const speakers = buildAllSpeakers();
      const {A, B} = balancedSplit(speakers);
      const mappingFlip = Math.random() < 0.5;
      const map = mappingFlip ? { Personality: 'A', Race: 'B' } : { Personality: 'B', Race: 'A' };
      State.order = Math.random() < 0.5 ? ['Personality','Race'] : ['Race','Personality'];
      const groupFor = blockName => (map[blockName] === 'A' ? A : B);
      State.blocks = {
        Personality: buildBlockTrials(groupFor('Personality'), 'Personality'),
        Race: buildBlockTrials(groupFor('Race'), 'Race')
      };
      intro.classList.add('hidden');
      renderBlock(State.order[0]);
    }

    function renderBlock(blockName) {
      State.currentBlock = blockName; State.trialIndex = 0; State.startedAt = performance.now();
      renderQuestions(CONFIG.questions[blockName]);
      blockTitle.textContent = `${blockName} Block`;
      block.classList.remove('hidden');
      updateTrialUI();
      nextBtn.onclick = handleNext;
    }

    function currentTrials() { return State.blocks[State.currentBlock]; }
    function currentTrial() { return currentTrials()[State.trialIndex]; }

    function updateTrialUI() {
      const trials = currentTrials();
      const t = currentTrial();
      const total = trials.length;
      trialCounter.textContent = `Trial ${State.trialIndex+1} / ${total}`;
      progressBar.style.width = `${((State.trialIndex)/total)*100}%`;
      player.src = t.url;
      console.log("Trial audio loaded:", player.src);
      nextBtn.disabled = true;
      renderQuestions(CONFIG.questions[State.currentBlock]);
    }

    function handleNext() {
      const t = currentTrial();
      const rt = Math.round(performance.now() - State.startedAt);
      const responses = {};
      CONFIG.questions[State.currentBlock].forEach((q, i) => {
        const sel = document.querySelector(`input[name="q${i}"]:checked`);
        responses[q] = sel ? sel.value : '';
      });
      State.data.push({
        block: t.block,
        trial_index: State.trialIndex+1,
        speaker: t.speaker,
        bin: t.bin,
        stimulus: t.stimulus,
        audio_url: t.url,
        ...responses,
        rt_ms: rt,
        timestamp: new Date().toISOString()
      });
      State.trialIndex++; State.startedAt = performance.now();
      const trials = currentTrials();
      if (State.trialIndex < trials.length) updateTrialUI();
      else {
        const idx = State.order.indexOf(State.currentBlock);
        if (idx === 0) renderBlock(State.order[1]);
        else { block.classList.add('hidden'); finish.classList.remove('hidden'); }
      }
    }

    downloadBtn.addEventListener('click', () => {
      if (!State.data.length) return;
      const csv = toCSV(State.data);
      const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = `responses.csv`;
      a.click(); URL.revokeObjectURL(url);
    });
  </script>
</body>
</html>
