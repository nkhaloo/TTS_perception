<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Racial Judgment Experiment</title>
  <style>
    body { font-family: sans-serif; background: #f5f5f5; margin: 0; padding: 20px; }
    .card { background: white; border-radius: 8px; padding: 20px; max-width: 700px; margin: 0 auto; box-shadow: 0 2px 6px rgba(0,0,0,0.1); }
    h1 { font-size: 24px; margin-top: 0; }
    .btn { padding: 10px 16px; border: none; border-radius: 6px; cursor: pointer; }
    .btn-primary { background: #007acc; color: white; }
    .hidden { display: none; }
    .progress { height: 8px; background: #eee; border-radius: 4px; margin: 10px 0; overflow: hidden; }
    .progress > div { height: 100%; background: #007acc; width: 0; }
    .scale { display: flex; gap: 6px; margin-top: 10px; }
    .scale label { flex: 1; text-align: center; padding: 6px 0; border: 1px solid #ccc; border-radius: 4px; cursor: pointer; }
    .scale input { display: none; }
    .scale input:checked + label { background: #007acc; color: white; border-color: #007acc; }
  </style>
</head>
<body>
  <div class="card" id="screen-intro">
    <h1>Audio Judgment Study</h1>
    <p>You will hear short recordings from different speakers and answer a quick question after each one. There are two blocks: Personality and Race. The assignment is randomized per participant.</p>
    <button class="btn btn-primary" id="startBtn">Start Experiment</button>
  </div>

  <div class="card hidden" id="screen-block">
    <h1 id="blockTitle">Block</h1>
    <div id="trialCounter">Trial 1 / 64</div>
    <div class="progress"><div id="progressBar"></div></div>
    <p>Please press Play to listen to the audio:</p>
    <audio id="player" preload="auto" controls></audio>
    <div id="questionText" style="margin-top:12px;">Placeholder question goes here.</div>
    <div class="scale" id="scale"></div>
    <div style="margin-top:12px;">
      <button class="btn btn-primary" id="nextBtn" disabled>Next</button>
    </div>
  </div>

  <div class="card hidden" id="screen-finish">
    <h1>All Done!</h1>
    <p>Thank you for participating. Download your responses below:</p>
    <button class="btn btn-primary" id="downloadBtn">Download CSV</button>
  </div>

  <script>
    const CONFIG = {
      assetsBase: 'data/soundfiles',
      stimuli: ['central', 'fronting', 'mono', 'raising'],
      suffix: '.wav',
      questions: {
        Personality: 'Placeholder personality question (1–7)',
        Race: 'Placeholder race question (1–7)'
      },
      bins: ['BF', 'BM', 'WF', 'WM'],
      numsPerBin: 8,
      scaleMin: 1,
      scaleMax: 7
    };

    function shuffle(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
      return array;
    }

    function buildAllSpeakers() {
      const speakers = [];
      for (const bin of CONFIG.bins) {
        for (let n = 1; n <= CONFIG.numsPerBin; n++) {
          speakers.push(`${bin}${n}`);
        }
      }
      return speakers;
    }

    function speakerPrefixToBin(prefix) {
      return prefix.replace(/\d+$/, '');
    }

    function balancedSplit(speakers) {
      const groupsByBin = Object.fromEntries(CONFIG.bins.map(b => [b, []]));
      for (const s of speakers) groupsByBin[speakerPrefixToBin(s)].push(s);
      for (const b of CONFIG.bins) shuffle(groupsByBin[b]);
      const groupA = [], groupB = [];
      for (const b of CONFIG.bins) {
        groupA.push(...groupsByBin[b].slice(0, 4));
        groupB.push(...groupsByBin[b].slice(4, 8));
      }
      return { A: groupA, B: groupB };
    }

    function buildBlockTrials(groupSpeakers, blockLabel) {
      const trials = [];
      for (const spk of groupSpeakers) {
        for (const stim of CONFIG.stimuli) {
          trials.push({
            block: blockLabel,
            speaker: spk,
            bin: speakerPrefixToBin(spk),
            stimulus: stim,
            // Use the same path style as the old working experiment
            url: `${CONFIG.assetsBase}/${stim}/${spk}_${stim}${CONFIG.suffix}`
          });
        }
      }
      return shuffle(trials);
    }

    function toCSV(rows) {
      const esc = v => '"' + String(v).replace(/"/g, '""') + '"';
      const headers = Object.keys(rows[0] || {});
      return [headers.join(','), ...rows.map(r => headers.map(h => esc(r[h] ?? '')).join(','))].join('\n');
    }

    const State = { blocks: {}, order: [], currentBlock: null, trialIndex: 0, data: [], startedAt: null };

    const intro = document.getElementById('screen-intro');
    const block = document.getElementById('screen-block');
    const finish = document.getElementById('screen-finish');
    const blockTitle = document.getElementById('blockTitle');
    const trialCounter = document.getElementById('trialCounter');
    const progressBar = document.getElementById('progressBar');
    const player = document.getElementById('player');
    const questionText = document.getElementById('questionText');
    const scaleDiv = document.getElementById('scale');
    const nextBtn = document.getElementById('nextBtn');
    const downloadBtn = document.getElementById('downloadBtn');

    function renderScale(min, max, onChange) {
      scaleDiv.innerHTML = '';
      for (let v = min; v <= max; v++) {
        const input = document.createElement('input');
        input.type = 'radio'; input.name = 'answer'; input.id = `ans_${v}`; input.value = String(v);
        const label = document.createElement('label');
        label.setAttribute('for', input.id); label.textContent = String(v);
        input.addEventListener('change', onChange);
        scaleDiv.appendChild(input); scaleDiv.appendChild(label);
      }
    }

    function getSelectedAnswer() {
      const el = document.querySelector('input[name="answer"]:checked');
      return el ? Number(el.value) : null;
    }

    function clearAnswer() {
      const el = document.querySelector('input[name="answer"]:checked');
      if (el) el.checked = false;
    }

    document.getElementById('startBtn').addEventListener('click', startExperiment);

    function startExperiment() {
      const speakers = buildAllSpeakers();
      const {A, B} = balancedSplit(speakers);
      const mappingFlip = Math.random() < 0.5;
      const map = mappingFlip ? { Personality: 'A', Race: 'B' } : { Personality: 'B', Race: 'A' };
      State.order = Math.random() < 0.5 ? ['Personality','Race'] : ['Race','Personality'];
      const groupFor = blockName => (map[blockName] === 'A' ? A : B);
      State.blocks = {
        Personality: buildBlockTrials(groupFor('Personality'), 'Personality'),
        Race: buildBlockTrials(groupFor('Race'), 'Race'),
      };
      intro.classList.add('hidden');
      renderBlock(State.order[0]);
    }

    function renderBlock(blockName) {
      State.currentBlock = blockName; State.trialIndex = 0; State.startedAt = performance.now();
      questionText.textContent = CONFIG.questions[blockName];
      renderScale(CONFIG.scaleMin, CONFIG.scaleMax, () => { nextBtn.disabled = getSelectedAnswer() == null; });
      blockTitle.textContent = `${blockName} Block`;
      block.classList.remove('hidden');
      updateTrialUI();
      nextBtn.onclick = handleNext;
    }

    function currentTrials() { return State.blocks[State.currentBlock]; }
    function currentTrial() { return currentTrials()[State.trialIndex]; }

    function updateTrialUI() {
      const trials = currentTrials();
      const t = currentTrial();
      const total = trials.length;
      trialCounter.textContent = `Trial ${State.trialIndex+1} / ${total}`;
      progressBar.style.width = `${((State.trialIndex)/total)*100}%`;
      // Use the same logic as the old working experiment
      player.src = `../${t.url}`;
      console.log("Trial audio loaded:", player.src);
      nextBtn.disabled = getSelectedAnswer() == null;
      clearAnswer();
    }

    function handleNext() {
      const t = currentTrial();
      const rt = Math.round(performance.now() - State.startedAt);
      const answer = getSelectedAnswer();
      State.data.push({
        block: t.block,
        trial_index: State.trialIndex+1,
        speaker: t.speaker,
        bin: t.bin,
        stimulus: t.stimulus,
        audio_url: t.url,
        answer,
        rt_ms: rt,
        timestamp: new Date().toISOString(),
      });
      State.trialIndex++; State.startedAt = performance.now();
      const trials = currentTrials();
      if (State.trialIndex < trials.length) updateTrialUI();
      else {
        const idx = State.order.indexOf(State.currentBlock);
        if (idx === 0) renderBlock(State.order[1]);
        else { block.classList.add('hidden'); finish.classList.remove('hidden'); }
      }
    }

    downloadBtn.addEventListener('click', () => {
      if (!State.data.length) return;
      const csv = toCSV(State.data);
      const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = `responses.csv`;
      a.click(); URL.revokeObjectURL(url);
    });
  </script>
</body>
</html>
